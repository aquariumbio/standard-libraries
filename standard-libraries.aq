{"config":{"title":"standard-libraries","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.2"},"components":[{"library":{"name":"Add Output","category":"Standard Libs","code_source":"module AddOutput\n    \n## Example\n        # operations.each do |op|\n        #     add_output op,\"Media\", \"YEB medium\", ObjectType\"200 mL Liquid\"\n        # end\n        #operations.make\n\n    def add_output operation, output_name, sample, container\n    ft = FieldType.new(\n                name: output_name,\n                ftype: \"sample\",\n                parent_class: \"OperationType\",\n                parent_id: nil\n            )\n            ft.save\n        \n            aft = AllowableFieldType.new({\n                field_type_id: ft.id,\n                sample_type_id: sample.sample_type.id,\n                object_type_id: ObjectType.find_by_name(container).id\n            })\n            aft.save\n            \n            fv = FieldValue.new(\n                name: \"Media\",\n                child_item_id: nil,\n                child_sample_id: sample.id,\n                role: 'output',\n                parent_class: \"Operation\",\n                parent_id: operation.id,\n                field_type_id: ft.id)\n            fv.allowable_field_type_id = aft.id\n            fv.save\n        \n    end\n\nend"}},{"library":{"name":"AssociationManagement","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Module with methods and classes that seek to help with associating data\n# to, and retrieving data from, items, operations, plans, collections, and parts.\n#\nmodule AssociationManagement\n  require 'matrix'\n\n  # Associates a key and value to the associations hash of the given object.\n  # Replaces an existing association for the given key.\n  #\n  # A part may be represented as a part item, or a collection and coordinate.\n  #\n  # @param object [DataAssociator]  the object to associate data\n  # @param key [String]  the key for the association\n  # @param data [serializable object]  the data for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [Array]  row, column pair if the object is a collection\n  # @option data_matrix [String]  optional data matrix for a collection\n  def associate_data(object, key, data, opts = {})\n    AssociationMap.associate_data(object, key, data, opts)\n  end\n\n  # Returns the associated value from the associations hash of a given object.\n  # If an association doesn't exist for the key, returns nil.\n  #\n  # @param object [DataAssociator]  the object to associated data\n  # @param key [String]  the key for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [tuple Array]  row, column of part if object is a collection.\n  # @option data_matrix [String]  optional data matrix\n  # @return [serializable object]  the value associated with the given key\n  def get_associated_data(object, key, opts = {})\n    AssociationMap.get_associated_data(object, key, opts)\n  end\n\n  # Defines a map to manage the associations for an {Item}, {Operation}, or\n  # {Plan} object, which are Aquarium classes that extend {DataAssociator}.\n  #\n  # Note: if `map` contains associations, it is necessary to call `map.save` for\n  #       the associations to be saved to Aquarium.\n  #\n  class AssociationMap\n    DATAMATRIX_KEY = 'part_data'\n\n    # Initializes an {AssociationMap} for the given item, operation, or plan.\n    #\n    # @param object [DataAssociator]  the object to which to associated data\n    def initialize(object)\n      @object = object\n      @map = {}\n\n      @object.associations.each do |datum|\n        @map[datum[0]] =\n          if @object.upload(datum[0]).nil?\n            datum[1]\n          else\n            UploadAssoc.new(datum[1], @object.upload(datum[0]))\n          end\n      end\n\n      if object.is_a? Collection\n        initialize_part_data\n        data_matrix_all(@object, @map[DATAMATRIX_KEY])\n      end\n    end\n\n    # Retrieves part_data from the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    def data_matrix_all(coll, data_matrix)\n      pas = coll.part_associations\n      part_ids = pas.collect(\u0026:part_id)\n      das = DataAssociation.where(parent_class: 'Item', parent_id: part_ids)\n      pas.each do |pa|\n        data_matrix[pa.row][pa.column] = {}\n        das.select { |da| da.parent_id == pa.part_id }.each do |da|\n          data_matrix[pa.row][pa.column][da.key] = da.value\n        end\n      end\n      data_matrix\n    end\n\n    # All in one static method which associates a key and value\n    # to the associations hash of a given object. If an association already\n    # exists at the given key, it will be replaced. Can associate to parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated. Can be an io field value\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when associating to a part of a collection, use a\n    #                         data matrix besides the default one\n    def self.associate_data(object, key, data, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot associate to a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        assoc_map.putrc(object.row, object.column, key, data)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        assoc_map.putrc(opts[:coord][0], opts[:coord][1], key, data)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        assoc_map.put(key, data)\n      end\n      assoc_map.save\n    end\n\n    # All in one static method which gets an associated value\n    # from the associations hash of a given object. If an association doesn't\n    # exist at the given key, returns nil. Can get associations from parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated, can be an io field value\n    # @param key [String]  the key for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when retrieving association from a part of a collection,\n    #                         use a matrix besides the default one\n    # @return [serializable object]  the data stored in the associations of the given object at the given key\n    def self.get_associated_data(object, key, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot get data from a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        return assoc_map.getrc(object.row, object.column, key)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.getrc(opts[:coord][0], opts[:coord][1], key)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.get(key)\n      end\n    end\n\n    # Adds an association for the data with the key.\n    # The data must be serializable.\n    #\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  Additional Options\n    # @option tag  [String]  If putting an Upload, optionally specify an extra label\n    def put(key, data, opts = { tag: {} })\n      @map[key] = if data.is_a?(Upload)\n                    UploadAssoc.new(opts[:tag], data)\n                  else\n                    data\n                  end\n    end\n\n    # Adds an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # If the data_matrix for the collection has not been created yet, it is initialized\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def putrc(row, column, key, data, data_matrix = DATAMATRIX_KEY)\n      # if the data_matrix for this collection does not exist yet, initialize it.\n      initialize_part_data(data_matrix)\n      @map[data_matrix][row][column][key] = data\n    end\n\n    # To be called when the object of association is a collection,\n    # establishes a matrix parallel to the sample matrix which can\n    # be used to store additional information about individual parts\n    # Each slot in the matrix will be a new empty hash.\n    #\n    # @param coll [Collection]  the object for which part-data matrix will be initialized\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def initialize_part_data(data_matrix = DATAMATRIX_KEY)\n      raise \"Invalid Method Call: cannot associate part data to an object that isn't a collection\" unless @object.is_a?(Collection)\n      # TODO: fix the following so that can use the Base method\n      # coll = collection_from(@object.id)\n      coll = Collection.find(@object.id)\n      @map[data_matrix] = Array.new(coll.dimensions[0]) { Array.new(coll.dimensions[1]) { {} } } if @map[data_matrix].nil?\n    end\n\n    # Returns the associated data for the key, if any.\n    #\n    # @param key [String]  the key for the association\n    # @returns the data object for the key, `nil` otherwise\n    def get(key)\n      data = @map[key]\n      if data.is_a?(UploadAssoc)\n        data.upload\n      else\n        data\n      end\n    end\n\n    # Gets an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # Returns the associated data for the key, if any.\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns the data object for the key, `nil` otherwise\n    def getrc(row, column, key, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix][row][column][key] unless @map[data_matrix].nil?\n    end\n\n    # Retrieve the associations for all parts of the collection\n    # as a matrix.\n    # @requires  current object is a collection\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns  the data matrix, if one exists\n    def get_data_matrix(data_matrix = DATAMATRIX_KEY)\n      Matrix.rows(@map[data_matrix])\n    end\n\n    # Replace or initialize the data matrix for this object\n    # with a custom one.\n    # @requires  the current object is a collection\n    # `matrix` have the same row column dimensions as the collection\n    #\n    # @param new_matrix [Matrix]  the new data matrix\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix (by key) to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n\n    def set_data_matrix(matrix, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix] = matrix.to_a\n    end\n\n    # Saves the associations in this map to Aquarium.\n    def save\n      das = []\n      @map.each_key do |key|\n        if key == DATAMATRIX_KEY\n          das.concat save_data_matrix_alt(@object, @map[key])\n        elsif @map[key].is_a? UploadAssoc\n          # TODO: update this to lazy associate once aq is updated to hav lazy upload assoc (on master, just not on server yet)\n          @object.associate(key, @map[key].tag, @map[key].upload)\n        else\n          das \u003c\u003c @object.lazy_associate(key, @map[key])\n        end\n      end\n      DataAssociation.import(das, on_duplicate_key_update: [:object]) unless das.empty?\n      @object.save\n      nil\n    end\n\n    # saves part_data to the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    # built off of set_data_matrix from collection.rb\n    def save_data_matrix_alt(coll, matrix, offset: [0, 0])\n      pm = coll.part_matrix\n      das = []\n\n      uniq_keys = matrix.flatten.map(\u0026:keys).flatten.uniq\n      dms_by_key = {}\n      uniq_keys.each do |key|\n        dms_by_key[key] = coll.data_matrix(key)\n      end\n\n      coll.each_row_col(matrix, offset: offset) do |x, y, ox, oy|\n        next unless !matrix[x][y].nil? \u0026\u0026 pm[ox][oy] # this part has das\n        matrix[x][y].each do |k, v|\n          if pm[ox][oy]\n            if dms_by_key[k][ox][oy]\n              da = dms_by_key[k][ox][oy]\n              da.object = { k =\u003e v }.to_json\n              das \u003c\u003c da\n            else\n              das \u003c\u003c pm[ox][oy].lazy_associate(k, v)\n            end\n          end\n        end\n      end\n\n      das\n    end\n\n    # Returns an array of all the keys in this map\n    def keys\n      @map.keys\n    end\n\n    # Returns the string representation of the map\n    def to_string\n      @map.to_s\n    end\n\n    alias to_s to_string\n  end\n\n  # private class that is used to deal with associating upload objects alongside their tag\n  class UploadAssoc\n    def initialize(tag, upload)\n      @upload = upload\n      @tag = tag || {}\n    end\n\n    def change_tag(new_tag)\n      @tag = new_tag\n    end\n\n    attr_reader :upload\n\n    attr_reader :tag\n  end\n\n  # Utilizes the part-data matrix of collections to store information about the history of\n  # parts of a collection. PartProvenance initializes and relies on two fields of every part-data\n  # slot: `source` and `destination`.\n  # `source` will store a list of item ids (with rc index if applicable),\n  # of all the ingredients used to make this part, and destination will use the same data format\n  # to record all of the places this part was used in.\n  # Item-Item provenance can technically be recorded as well with this library, but it will not\n  # be necessary.\n  #\n  module PartProvenance\n    SOURCE = 'source'\n    DESTINATION = 'destination'\n\n    # Record an entry to the provenance data between two parts, or a part and an item.\n    # This will populate the destination field of `from`, and the source field\n    # of the `to` in their respective associations. If from_coord or to_coord is specified, then\n    # the associations of the part of the from/to collection at that coordinate will\n    # populated instead.\n    #\n    # @param opts [Hash]  Arguments specifying which objects to record relation for\n    # @option from [Item/Collection]  the item or collection where sample transfer originated\n    # @option to [Item/Collection]  the item or collection for destination of sample transfer\n    # @option from_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `to` was a collection\n    # @option to_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `from` was a collection\n    # @option additional_relation_data [Hash]  optionally, add additional key/value pairs to add to both object's routing data\n    #                         for this relation. For example, you might want to specify the volume of the transfer,\n    #                         or which colony was picked from a plate\n    # @option from_map [AssociationMap]  existing AssociationMap for the given from-object, required to successfully associate provenance to\n    #                           the `from` item\n    # @option to_map [AssociationMap]  existing AssociationMap for the given to-object, required to successfully associate provenance to\n    #                           the `to` item\n    def add_provenance(opts = {})\n      if opts[:from] == opts[:to] # special case: provenance between two parts on the same collection\n        opts[:from_map] = opts[:to_map] # ensure from map and to map are the same object for this case\n      end\n\n      # creating information hashes to represent `from` and `to` relationship data\n      from_info = serialize_as_simple_tag(opts[:from], opts[:from_coord], opts[:additional_relation_data])\n      to_info = serialize_as_simple_tag(opts[:to], opts[:to_coord], opts[:additional_relation_data])\n\n      # in destination field of `from`, add information tag representing `to`\n      append_to_association(opts[:from_map], DESTINATION, to_info, coord: opts[:from_coord]) if opts[:from_map]\n\n      # in source field of `to`, add information tag representing `from`\n      append_to_association(opts[:to_map], SOURCE, from_info, coord: opts[:to_coord]) if opts[:to_map]\n    end\n\n    # Retrieves a list of sources that were used to construct the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def sources(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, SOURCE, coord: coord)\n      else\n        AssociationMap.get_associated_data(object, SOURCE)\n      end\n    end\n\n    # Retrieves a list of destinations that were made using the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def destinations(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, DESTINATION, coord: opts[:coord])\n      else\n        AssociationMap.get_associated_data(object, DESTINATION)\n      end\n    end\n\n    # For the given associatable target object, appends or concatenates the given datum_to_append to the association\n    # at `key` for that object\n    #\n    # @param association_map [AssocioationMap]  an AssociationMap that will have its associations appended to.\n    # @param key [String/Symbol]  The association key which maps to an appendable object\n    # @param datum_to_append [Serializable Object]  the element to append to the list at the value for the given key\n    # @param opts [Hash]  additional options\n    # @option coord [Tuple array]  coordinate of target part, if association target is a collection\n    def append_to_association(association_map, key, datum_to_append, opts = {})\n      if opts[:coord] # we will be interacting with the associations of a part of a collection if coord is specified\n        association_map.putrc(opts[:coord][0], opts[:coord][1], key, []) if association_map.getrc(opts[:coord][0], opts[:coord][1], key).nil?\n        association_map.getrc(opts[:coord][0], opts[:coord][1], key) \u003c\u003c  datum_to_append\n      else\n        association_map.put(key, []) if association_map.get(key).nil?\n        association_map.get(key) \u003c\u003c datum_to_append\n      end\n    end\n\n    # Given an item, or a part of a collection, serializes it into a simple tag which can be used to retrieve it.\n    #\n    # @param item [Item/FieldValue]  can be either an Item, or\n    #                         an i/o object corresponding to a part of a collection, which can be thought of\n    #                         as constituting a 'sub item'\n    def serialize_as_simple_tag(item, coord, additional_info)\n      info = if item.collection? \u0026\u0026 coord\n               { id: item.id, row: coord[0], column: coord[1] }\n             elsif (item.is_a? Item) || (item.is_a? Collection)\n               { id: item.id }\n             else\n               raise 'Argument is neither a part nor an item'\n             end\n      info.merge!(additional_info) unless additional_info.nil?\n      info\n    end\n  end\nend\n"}},{"library":{"name":"Centrifuge","category":"Standard Libs","code_source":"# abemill@uw.edu\n# This module is made to cover all common cases of directing the tech to\n# centrifuge, decant, and resuspend multiple batches of tubes.\n# centrifuge_resuspend_cycle is the public method of this module.\n# It allows staggered centrifuging so that the tech can be resuspending\n# the previous batch while the next batch is centrifuging.\nmodule Centrifuge\n  class Batch\n    attr_reader :marker, :tubes\n\n    def initialize(args)\n      @marker = args[:marker]\n      @tubes = args[:tubes]\n    end\n\n    # Partition the given tubes list into batches.\n    # Returns a list of Batch objects, each having a letter marker, and a list\n    # of tubes.\n    def self.initialize_batches(tubes, centrifuge_slots, protocol)\n      @@protocol = protocol # we need this to use show commands in Batch methods\n      @@batch_size = centrifuge_slots\n      tube_batches = tubes.each_slice(centrifuge_slots).to_a\n      batches = []\n      tube_batches.each_with_index do |tube_batch, i|\n        batch_id = [(i + 65).chr]\n        batches.push Batch.new(marker: batch_id, tubes: tube_batch)\n      end\n      batches\n    end\n    \n    def self.batch_size\n      @@batch_size\n    end\n\n    # returns a new list of batches produced by reducing the amount of tubes in\n    # each batch and then combining batches, Batches.size will be halved.\n    def self.combine_batches(batches)\n      paired_batches = batches.each_slice(2).to_a\n      batches = []\n      paired_batches.each do |pair|\n        pair.each_with_index do |batch, i|\n          pair[i] = batch.combine_tubes\n        end\n        batches.push(pair[0].combine_with(pair[1]))\n      end\n      batches\n    end\n\n    # Instructs tech to reduce the number of tubes in the given batch by a power\n    # of 2, combining tubes of the same sample. This only shows the instructions\n    # and does not alter the state of batches[].\n    # (that happens in combine_batches)\n    def combine_tubes_instructions()\n      batch = self\n      @@protocol.show do\n        title 'Combine Tubes'\n        if batch.marker.length == 1\n          note 'Reduce the number of tubes in '\\\n               \"\u003cb\u003ebatch #{batch.marker.to_sentence}\u003c/b\u003e from #{batch.tubes.length} \"\\\n               \"to #{batch.tubes.length / 2} by combining tubes.\"\n        else\n          note \"Together, \u003cb\u003ebatches #{batch.marker.to_sentence}\u003c/b\u003e have a \"\\\n               \"total of #{batch.tubes.length} tubes. Reduce the sum of tubes to \"\\\n               \"#{batch.tubes.length / 2} by combining tubes from \"\\\n               \"#{batch.marker.length == 2 ? 'both' : 'all'} batches.\"\n        end\n        note 'Combine tubes by carefully pouring one tube into tube '\\\n             'that shares the same id.'\n        note 'All tubes after combination should have the same volume. '\\\n             'Do not \"double combine\" any tubes.'\n        batch.tubes.uniq.each do |tube|\n          note \"Combine each tube labeled \u003cb\u003e#{tube}\u003c/b\u003e \"\\\n               \"with another tube labeled \u003cb\u003e#{tube}\u003c/b\u003e.\"\n        end\n        if Cycle.cold?\n          warning 'Once finished with combining, '\\\n                  'immediately place tubes in ice bath.'\n        end\n      end\n    end\n\n    # instructions to place tubes from batch into the centrifuge\n    def centrifuge(centrifuge_instructions)\n      rpm = centrifuge_instructions[:rpm]\n      time = centrifuge_instructions[:time]\n      temp = centrifuge_instructions[:temp]\n      batch = self\n      @@protocol.show do\n        title 'centrifuge tubes'\n        note \"Set the centrifuge to #{rpm} rpm for #{time} minutes at \"\\\n             \"#{temp} C. Ensure correct centrifuge tube holders are in place.\"\n        note \"Move all tubes from \u003cb\u003e#{'batch'.pluralize(batch.marker.length)} \"\\\n             \"#{batch.marker.to_sentence}\u003c/b\u003e to centrifuge and press start.\"\n        if batch.tubes.length.odd?\n          warning 'Balance the centrifuge with a dummy tube that is filled '\\\n                  'with the same volume of liquid as the other tubes.'\n        end\n      end\n    end\n\n    # instructions to remove tubes from the centrifuge\n    # after it has finished a spin\n    def remove_tubes()\n      batch = self\n      @@protocol.show do\n        title 'Remove Tubes from Centrifuge'\n        note 'Wait for centrifuge to finish'\n        note 'Once the centrifuge has finished its spin, '\\\n             'remove tubes from centrifuge.'\n        note \"The removed tubes should be marked as \"\\\n             \"\u003cb\u003e#{'batch'.pluralize(batch.marker.length)} \"\\\n             \"#{batch.marker.to_sentence}\u003c/b\u003e.\"\n        if Cycle.cold?\n          warning 'Once removed from centrifuge, '\\\n                'immediately place tubes in ice bath.'\n        end\n      end\n    end\n\n    # instructions to resuspend tubes\n    def resuspend(resuspend_instructions)\n      volume = resuspend_instructions[:volume]\n      media = resuspend_instructions[:media]\n\n      decant()\n\n      batch = self\n      @@protocol.show do\n        title \"Resuspend cells in #{volume}mL of #{media}\"\n        note \"Grab bottle of #{media} from fridge.\"\n        note \"Carefully pour #{volume}mL of #{media} into each tube from \u003cb\u003e\"\\\n             \"#{'batch'.pluralize(batch.marker.length)} #{batch.marker.to_sentence}\u003c/b\u003e.\"\n        note 'Shake and vortex tubes until pellet is completely resuspended.'\n        warning 'When not actively shaking or vortexing keep tubes in ice, '\\\n                'and place all tubes in ice once resuspended.' if Cycle.cold?\n        note \"At next opportunity, bring #{media} back to fridge, \"\\\n             'or to dishwasher if empty.'\n      end\n    end\n\n    def decant()\n      batch = self\n      @@protocol.show do\n        title 'Decant tubes'\n        note \"Take #{Cycle.cold? ? 'ice bucket' : 'tubes'} to the \"\\\n             \"dishwasing station, and pour out supernatant of tubes from \u003cb\u003e\"\\\n             \"#{'batch'.pluralize(batch.marker.length)} #{batch.marker.to_sentence}\u003c/b\u003e.\"\n        note 'Place tubes in ice immediately after decanting.' if Cycle.cold?\n      end\n    end\n\n    # returns new batch which is the combination of this batch\n    # and the other batch\n    # helper for combine_batches\n    def combine_with(other)\n      if other\n        new_marker = marker.concat other.marker\n        new_tubes = tubes.concat other.tubes\n        return Batch.new(marker: new_marker, tubes: new_tubes)\n      else\n        return self\n      end\n    end\n\n    # returns a new batch with a half the tubes, where like tubes have been\n    # combined.\n    # helper for combine_batches\n    def combine_tubes\n      new_tubes = []\n      new_tubes.concat(tubes)\n      batch = Batch.new(marker: marker,tubes: [])\n      tubes.uniq.each do |short_id|\n        sameids = new_tubes.select { |tube| tube == short_id }\n        batch.tubes.concat(sameids[0, sameids.length / 2])\n      end\n      batch\n    end\n  end\n\n  class Cycle\n    attr_reader :centrifuge_instructions, :resuspend_instructions\n    def initialize(cycle_instructions)\n      @centrifuge_instructions = { temp: cycle_instructions[:cent_temp],\n                                   rpm: cycle_instructions[:cent_rpm],\n                                   time: cycle_instructions[:cent_time] }\n\n      @resuspend_instructions = { media: cycle_instructions[:sus_media],\n                                  volume: cycle_instructions[:sus_volume] }\n\n      @combine = cycle_instructions[:combine]\n    end\n\n    def self.initialize_cycles(cycles_data, cold)\n      @@cold = cold\n      cycles = cycles_data.map do |cycle_data|\n        Cycle.new(cycle_data)\n      end\n      cycles\n    end\n\n    def self.cold?\n      @@cold\n    end\n\n    def combine?\n      @combine\n    end\n  end\n\n  ##\n  # @param [Hash] opts  The parameters which indicate cycling behaivor\n  # @option [Array\u003cItem\u003e] items  The array of items for which each will\n  #           be split into smaller tubes and then centrifuge cycled on.\n  # @option [Float] start_vol  Volume of liquid that each item begins with.\n  # @option [Float] tube_vol  Volume of centrifuge tubes that\n  #           start_vol will be divided amongst\n  # @option [Integer] centrifuge_slots  Number of slots in the centrifuge.\n  #           Must be an even number.\n  # @option [Array\u003cHash\u003e] cycles  Instructions for each cycle of centrifuging.\n  #           Cycles.length indicates how many centrifuge/wash cycles.\n  #           Elements of cycles contain instructions for the centrifuging\n  #           and resuspension settings for that cycle.\n  # @option [Boolean] :cold  Indicate if centrifuge cycling is done on ice.\n  #           Default: no\n  # @option [Symbol] :cb_extra_instructions  Extra instructions for tech\n  #           while waiting for final centrifuge batch to finish,\n  #           for example, tidying up workspace. Default: none\n  # @effects  This method Instructs tech to do cycles of centrifuging,\n  #           decanting, and resuspending on each item\n  #           as per the instructions stored in cycles.\n  def centrifuge_resuspend_cycle(opts = {})\n    # Bench setup is required before we begin centrifuging\n    # During setup, the items will be aliquoted into tubes,\n    # and each aliquoted tube will be marked with a short id.\n    # This maps tubes to the item they originated from, and will\n    # keep track of which tubes contain the same substance.\n    # the index of the parent item in the items[] is used\n    # for the short id.\n    # Also, tubes are grouped into batches that will fit in centrifuge,\n    # and marked with a capital letter batch identifier, in addition to their\n    # short id that indicates their ancestry.\n\n    # computation\n    tubes = initialize_tubes(opts)\n    batches = Batch.initialize_batches(tubes, opts[:centrifuge_slots], self)\n    cycles = Cycle.initialize_cycles(opts[:cycles], opts[:cold])\n\n    # tech instructions\n    setup_steps(cycles, batches,\n              opts[:start_vol], opts[:tube_vol], opts[:items])\n\n    # Loop through each cycle of centrifuging and resuspending found in cycles[]\n    # and perform that cycle on each batch of tubes in found in batches[]\n    this_batch = nil\n    cycles.each_with_index do |cycle, i|\n      prev_cycle = cycles[i - 1]\n      \n      # Reconfigure batches array to be shortened by combing batches\n      # so each batch has enough tubes to fill centrifuge.\n      batches = Batch.combine_batches(batches) if prev_cycle.combine?\n\n      batch_iterator = batches.each\n      first_batch = batch_iterator.next\n      if i.zero?\n        # first batch of first cycle, the centrifuge is empty\n        first_batch.centrifuge(cycle.centrifuge_instructions)\n      else\n        this_batch.remove_tubes\n        if batches.length == 1\n          # this_batch == first_batch || first_batch contains this_batch\n          this_batch.resuspend(prev_cycle.resuspend_instructions)\n          this_batch.combine_tubes_instructions if prev_cycle.combine?\n          first_batch.centrifuge(cycle.centrifuge_instructions)\n        else\n          # first_batch and this_batch are not associated,\n          # we can start centrifuging first_batch before we resuspend this_batch\n          first_batch.centrifuge(cycle.centrifuge_instructions)\n          this_batch.resuspend(prev_cycle.resuspend_instructions)\n          this_batch.combine_tubes_instructions if prev_cycle.combine?\n        end\n      end\n\n      this_batch = first_batch\n      while has_next? batch_iterator\n        next_batch = batch_iterator.next\n        this_batch.remove_tubes\n        next_batch.centrifuge(cycle.centrifuge_instructions)\n        this_batch.resuspend(cycle.resuspend_instructions)\n        this_batch.combine_tubes_instructions if cycle.combine?\n        this_batch = next_batch\n      end\n    end\n\n    # Show any extra steps specified by client to do\n    # while waiting for last spin to finish.\n    extra_instructions(opts[:cb_extra_instructions])\n\n    final_cycle = cycles.last\n    this_batch.remove_tubes\n    this_batch.resuspend(final_cycle.resuspend_instructions)\n    if final_cycle.combine?\n      this_batch.combine_tubes_instructions\n      batches = Batch.combine_batches(batches)\n    end\n\n    # On remaining tubes,\n    # replaces the short id with the id of original parent item.\n    relabel_tubes(batches, opts[:items])\n  end\n\n  private\n\n  # Ensures state of variables is acceptable\n  # TODO add more checks\n  def error_checks(cycles, batches, opts)\n    raise 'odd slot centrifuge not supported' if Batch.batch_size.odd?\n    raise 'wrong cycle amount' if cycles.length != opts[:cycles].length\n    raise 'wrong batch size' if Batch.batch_size != opts[:centrifuge_slots]\n  end\n\n  # Initializes array of integers that represent tubes\n  # identified by their short_id which corresponds to the parent item.\n  # Also returns\n  def initialize_tubes(opts)\n    combination_occurs = opts[:cycles].any? { |cycle| cycle[:combine] == true }\n    tubes_per_item = (opts[:start_vol] / opts[:tube_vol]).floor\n    tubes_per_item += 1 if tubes_per_item.odd? \u0026\u0026 combination_occurs\n    tubes = []\n    opts[:items].each_with_index do |_item, i|\n      tubes_per_item.times do\n        tubes.push (i + 1)\n      end\n    end\n    tubes\n  end\n\n  # Gives the tech instructions to prepare for centrifuging.\n  def setup_steps(cycles, batches, start_vol, tube_vol, items)\n    tubes = batches.map { |batch| batch.tubes }.flatten\n\n    fetch_supplies(cycles, tubes.length, tube_vol)\n    if Cycle.cold?\n      prepare_ice_bath\n      chill_tubes(tubes.length, tube_vol)\n    end\n    aliquot_items_to_tubes(items, tubes, start_vol, tube_vol)\n    batch_tubes_instructions(batches)\n  end\n\n  # Instructs tech to fetch all the media and tubes that will be required.\n  def fetch_supplies(cycles, num_tubes, tube_vol)\n    media_to_volume = calculate_media_volumes(cycles, num_tubes)\n\n    media_location = 'on bench'\n    tube_location = 'on bench'\n    if Cycle.cold?\n      media_location = 'in fridge'\n      tube_location = 'in freezer'\n    end\n\n    show do\n      title 'Grab required suspension media'\n      note 'For the following set of centrifuging instructions, you will need'\\\n           ' the following supplies: '\n      media_to_volume.each do |media, volume|\n        check \"At least #{volume}mL of #{media}\"\n      end\n      note \"Place all media bottles #{media_location}\"\\\n           ' in preparation for centrifuge.'\n      note \"Place #{num_tubes} #{tube_vol}mL tubes #{tube_location}\"\\\n           ' in preparation for centrifuge.'\n    end\n  end\n\n  def calculate_media_volumes(cycles, num_tubes)\n    media_to_volume = Hash.new\n    media_list = cycles.map do |cycle|\n      cycle.resuspend_instructions[:media]\n    end.uniq\n\n    media_list.each do |media|\n      volumes = cycles.select { |cycle|\n        cycle.resuspend_instructions[:media] == media\n      }.map { |cycle|\n        cycle.resuspend_instructions[:volume]\n      }\n      total_volume = volumes.sum * num_tubes\n      media_to_volume[media] = total_volume\n    end\n    media_to_volume\n  end\n\n  # Instructs tech to make an ice bath and immerse empty tubes in it.\n  def prepare_ice_bath\n    show do\n      title 'Go to Bagley to get ice (Skip if you already have ice)'\n      note 'Walk to ice machine room on the second floor in Bagley with a '\\\n           'large red bucket, fill the bucket  full with ice.'\n      note 'If unable to go to Bagley, use ice cubes to make a water bath (of '\\\n           'mostly ice) or use the chilled aluminum bead bucket. (if using '\\\n           'aluminum bead bucket place it back in freezer between spins)'\n    end\n  end\n\n  def chill_tubes(num_tubes, tube_vol)\n    show do\n      title 'Prepare chilled tubes'\n      note \"Take the #{num_tubes} #{tube_vol}mL \"\\\n            \"#{'tube'.pluralize(num_tubes)} from the freezer \"\\\n            'and immerse in ice bath.'\n    end\n  end\n\n  # Instructs the tech to divide the volume of each item in items[] into\n  # equivolume aliquots for centrifuging.\n  def aliquot_items_to_tubes(items, tubes, start_vol, tube_vol)\n    tubes_per_item = tubes.length / items.length\n    aliquot_amount = [start_vol / tubes_per_item, tube_vol].min\n\n    show do\n      title \"Aliquot items into #{tube_vol}mL tubes for centrifuging\"\n      note 'You should have '\\\n           \"#{items.length * tubes_per_item} #{tube_vol}mL tubes.\"\n      if Cycle.cold?\n        note 'While labeling and pouring, '\\\n             'leave tubes in ice bath as much as possible.'\n      end\n      items.each_with_index do |item, i|\n        note \"Label #{tubes_per_item} tubes with short id: \u003cb\u003e#{i + 1}\u003c/b\u003e\"\n        note \"Carefully pour #{aliquot_amount}mL from #{item} \"\\\n             \"into each tube labeled as \u003cb\u003e#{i + 1}\u003c/b\u003e.\"\n      end\n      \n      if Cycle.cold?\n        note 'Leave tubes to chill for for 30 minutes.'\n        timer initial: { hours: 0, minutes: 30, seconds: 0}\n      end\n    end\n  end\n  \n  # Instructs the tech to group tubes into batches\n  # that will fit into the centrifuge\n  def batch_tubes_instructions(batches)\n    show do\n      title \"separate tubes into batches of #{Batch.batch_size} or less\"\n      note 'Group tubes into batches as shown and mark each tube '\\\n           'with its alphabetic batch identifier.'\n      batches.each do |batch|\n        check \"\u003cb\u003e#{batch.tubes.to_sentence}\u003c/b\u003e: \"\\\n              \"batch \u003cb\u003e#{batch.marker}\u003c/b\u003e\"\n      end\n    end\n  end\n  \n  # Callback which runs client specified method during the time when\n  # the tech is waiting for the last batch of tubes to finish centrifuging.\n  def extra_instructions(method_name)\n    method(method_name.to_sym).call if method_name \u0026\u0026 (method_name != '')\n  end\n\n  # After centrifuging finishes, instruct tech to relabel the resulting tubes\n  # with the id of the item that they originated from, for convienence.\n  def relabel_tubes(batches, items)\n    result_tubes = batches.map { |batch| batch.tubes }.flatten\n    show do\n      title 'Label Finished Tubes'\n      note 'Tubes with the following ids remain: '\\\n           \"\u003cb\u003e#{result_tubes.to_sentence}\u003c/b\u003e.\"\n      note 'Label each tube with the item id '\\\n           'of the item that they originated from.'\n      items.each_with_index do |item, i|\n        note \"The tube(s) labeled as \u003cb\u003e#{i + 1}\u003c/b\u003e \"\\\n             \"should be relabeled as \u003cb\u003e#{item.id}\u003c/b\u003e.\"\n      end\n    end\n  end\n\n  # Helper method that allows manual iteration like in java\n  # when used alongside enumerator.next()\n  def has_next?(enum)\n    enum.peek\n    return true\n  rescue StopIteration\n    return false\n  end\nend\n"}},{"library":{"name":"CommonInputOutputNames","category":"Standard Libs","code_source":"module CommonInputOutputNames\n\n    INPUT_YEAST = 'Yeast Culture'\n    OUTPUT_YEAST = 'Yeast Culture'\n    MEDIA = 'Media'\n    DNA = 'DNA'\n    \n    INPUT_SAMPLE = 'Input Sample'\n    OUTPUT_SAMPLE = 'Output Sample'\n\n    FORWARD_PRIMER = 'Forward Primer'\n    REVERSE_PRIMER = 'Reverse Primer'\n    TEMPLATE = 'Template'\n    FRAGMENT = 'Fragment'\n    PROGRAM = 'Program'\n    PRIMER_PLATE = '96-Well Primer Aliquot Plate'\n\nend"}},{"library":{"name":"Debug","category":"Standard Libs","code_source":"module Debug\n  def print_object obj\n    if [Numeric, String].any? { |c| obj.is_a? c }\n      obj\n    elsif [Array].any? { |c| obj.is_a? c }\n      obj.map { |item| print_object item }\n    elsif [Hash].any? { |c| obj.is_a? c }\n      Hash[obj.map { |k, v| [k, print_object(v)] }]\n    else\n      s = obj ? obj.id.to_s : \"\"\n      s += \" #{obj.name}\" if obj.class.method_defined? :name\n      s\n    end\n  end\n\n  def log_info *args\n    if debug\n      show do\n        title \"Debug slide (#{args.length} #{\"arg\".pluralize args.length})\"\n\n        args.each do |arg|\n          note \"#{arg.class}: #{print_object arg}\"\n        end\n      end\n    end\n  end\n\n  def inspect(object, ident=nil)\n    show do\n      title \"\u003cspan style=\\\"background-color:yellow\\\"\u003eINSPECTING #{ident} (#{object.class})\u003c/span\u003e\"\n      if object.kind_of?(Array)\n        table object\n      else\n        note object.to_json\n      end\n    end\n  end\nend\n"}},{"library":{"name":"Feedback","category":"Standard Libs","code_source":"module Feedback\n  CONTAINER_NAME = \"Feedback (Virtual)\"\n  SAMPLE_TYPE_NAME = \"Operation Feedback\"\n  \n  # This method will prompt the technician to write feedback for the operations\n  # that they complete on each job. This feedback will be associated to an item\n  # that represents each operation type.\n  def get_protocol_feedback\n    \n    # Gets feedback from the user\n    if debug\n      feedback = \"testing for job id\"\n    else\n      feedback = ask_for_feedback\n    end\n    \n    if(!feedback.blank?)\n      associate_feedback feedback\n    end\n    \n    if debug\n      print_association\n    end\n    \n  end\n  \n  # Associates the feedback entered by the lab technician to the OperationType of the protocol\n  # that uses this library.\n  #\n  # @param [String] the feedback entered by the lab technician.\n  def associate_feedback feedback\n    operation = OperationType.find(operation_type.id)\n    feedback = feedback + \"- job #{jid}\"\n  \n    feedback_array = []\n    if(!operation.get(:feedback).nil?)\n      feedback_array = operation.get(:feedback)\n    end\n    feedback_array.push(feedback)\n    operation.associate :feedback, feedback_array\n  end\n  \n  # Debugging method that prints all associations\n  def print_association\n    operation = OperationType.find(operation_type.id)\n    feedback_array = operation.get(:feedback)\n    if feedback_array\n      show do\n        title \"This is printing because debug is on\"\n        note \"#{feedback_array}\"\n      end\n    end\n  end\n  \n  # Returns the feedback entered by a lab technician.\n  #\n  # @return [Hash] the information returned by the feedback show block\n  def ask_for_feedback\n    feedback = show do\n      title \"We want your feedback\"\n      \n      note \"Notice anything weird with this protocol? Tell us below!\"\n      \n      get \"text\", var: \"feedback_user\", label: \"Enter your feedback here\", default: \"\"\n    end\n    feedback[:feedback_user] # return\n  end\n\nend"}},{"library":{"name":"InputOutput","category":"Standard Libs","code_source":"module InputOutput\n  def add_static_inputs ops, name, sample_name, container_name\n    ops.each do |op|\n      sample = Sample.find_by_name(sample_name)\n      container = ObjectType.find_by_name(container_name)\n      op.add_input name, sample, container\n      op.input(name).set item: sample.in(container.name).first\n    end\n  end\n  \n  def get_inputs_checked input_name\n    show do\n      title \"Gather the following item(s)\"\n       \n      operations.each do |op|\n        check \"#{op.input(input_name).item.id}: #{op.input(input_name).sample.name} at \u003cb\u003e#{op.input(input_name).item.location}\u003c/b\u003e\"\n      end\n    end\n  end\nend"}},{"library":{"name":"ItemActions","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Assists with basic actions of items (eg trashing, moving, etc)\n\nmodule ItemActions\n  # Store all items used in input operations\n  # Assumes all inputs are non nil\n  #\n  # @param operations [OperationList] the list of operations\n  # @param location [String] the storage location\n  # @param type [String] the type of items to be stored('item', 'collection')\n  def store_inputs(operations, location: nil, type: nil)\n    store_io(operations, role: 'input', location: location, type: type)\n  end\n\n  # Stores all items used in output operations\n  # Assumes all outputs are non nil\n  #\n  # @param operations [OperationList] the operation list where all\n  #     output collections should be stored\n  # @param location [String] the storage location\n  # @param type [String] the type of items to be stored ('item', 'collection')\n  def store_outputs(operations, location: nil, type: nil)\n    store_io(operations, role: 'output', location: location, type: type)\n  end\n\n  # Stores all items of a certain role in the operations list\n  # Creates instructions to store items as well\n  #\n  # @param operations [OperationList] list of Operations\n  # @param role [String] whether material to be stored is an input or an output\n  # @param location [String] the location to store the material\n  # @param all_items [Boolean] an option to store all items not just collections\n  # @param type [String] the type of items to be stored ('item', 'collection')\n  def store_io(operations, role: 'all', location: nil, type: nil)\n    items = Set[]; role.downcase!; type.downcase!\n    operations.each do |op|\n      field_values = if role == 'input'\n                       yield op.inputs\n                     elsif role == 'output'\n                       yield op.outputs\n                     else\n                       yield (op.outputs + op.inputs)\n                     end\n\n      unless type.nil?\n        if type == 'collection'\n          field_values.reject! { |fv| fv.object_type.handler == 'collection' }\n        elsif type == 'item'\n          field_values.select! { |fv| fv.object_type.handler == 'collection' }\n        end\n      end\n\n      items.concat(field_values.map(\u0026:item))\n    end\n    store_items(items, location: location)\n  end\n\n  # Instructions to store a specific item\n  # TODO have them move the items first then move location in AQ\n  #\n  # @param items [Array\u003citems\u003e] the things to be stored\n  # @param location [String] Sets the location of the items if included\n  def store_items(items, location: nil)\n    set_locations(items, location) unless location.nil?\n    tab = create_location_table(items)\n    show do\n      title 'Put Away the Following Items'\n      table tab\n    end\n  end\n\n  # Sets the location of all objects in array to some given locations\n  #\n  # @param items Array[Collection] or Array[Items] an array of any objects\n  # that extend class Item\n  # @param location [String] the location to move object to\n  # (String or Wizard if Wizard exists)\n  def set_locations(items, location)\n    items.each do |item|\n      item.move_to(location)\n      item.save\n    end\n  end\n\n  # Directions to layout materials for easy use\n  #\n  # @materials [Array\u003citems\u003e]\n  def layout_materials(materials)\n    show do\n      title 'Layout Materials'\n      note 'Please set out the following items for easy access'\n      table create_location_table(materials)\n    end\n  end\n\n  # Directions to retrieve materials\n  #\n  # @materials [Array\u003citems\u003e]\n  def retrieve_materials(materials)\n    show do\n      title 'Retrieve Materials'\n      note 'Please get the following items'\n      table create_location_table(materials)\n    end\n  end\n\n  # Creates table directing technician on where to store materials\n  #\n  # @param collection [Collection] the materials that are to be put away\n  # @return location_table [Array\u003cArray\u003e] of Collections and their locations\n  def create_location_table(items)\n    location_table = [['ID', 'Object Type', 'Location']]\n    items.each do |item|\n      location_table.push([item.id, item.object_type.name, item.location])\n    end\n    location_table\n  end\n\n  # Gives directions to throw away objects (collection or item)\n  #\n  # @param items [Array\u003citems\u003e] Items to be trashed\n  # @param hazardous [boolean] if hazardous then true\n  def trash_object(items, waste_container: 'Biohazard Waste')\n    set_locations(items, location: waste_container)\n    tab = create_location_table(items)\n    show do\n      title 'Properly Dispose of the following items:'\n      table tab\n    end\n    items.each { |item| item.mark_as_deleted }\n  end\nend\n"}},{"library":{"name":"LabwareNames","category":"Standard Libs","code_source":"needs \"Standard Libs/Units\"\n\nmodule LabwareNames\n    include Units\n    \n    # Tubes\n    TUBE_50_ML_CONICAL = \"50 #{MILLILITERS} conical tube\"\n    TUBE_15_ML_CONICAL = \"15 #{MILLILITERS} conical tube\"\n    TUBE_MICROFUGE = \"1.5 #{MILLILITERS} microcentrifuge tube\"\n    TUBE_MICROCENTRIFUGE = TUBE_MICROFUGE\n    \n    # Plates\n    PCR_PLATE = \"0.2 #{MILLILITERS} PCR plate\"\n    \n    # Misc\n    \"96-well -20#{DEGREES_C} cold blocks\"\nend"}},{"library":{"name":"MatrixTools","category":"Standard Libs","code_source":"# Module containing WellMatrix Class\n#\nmodule MatrixTools\n  require 'matrix'\n  # Defines a wrapper for a 2D array containing data for each of the wells of a\n  # 24 or 96 well plate.\n  #\n  # A WellMatrix object can be easily converted to or from a ruby Matrix as\n  # needed to allow the use of matrix operations.\n  #\n  class WellMatrix\n    # Initializes a WellMatrix object using an array of rows.\n    #\n    # @param rows [Array\u003cArray\u003cObject\u003e\u003e]  the rows of the matrix\n    # @raises [WellMatrixInvalidDimensionsError]\n    #              if `rows` is not size 24 or 96\n    #              or if `rows` does not have consistent column size\n    def initialize(rows)\n      @rows = rows\n      check_rep\n    end\n\n    # Returns a new WellMatrix as a copy of the given Matrix.\n    #\n    # @param matr [Matrix]  the Matrix from which to construct a new WellMatrix\n    # @returns [WellMatrix]  new WellMatrix object with identical elements\n    #          as the passed in Matrix\n    # @raises [WellMatrixInvalidDimensionsError]  if `matrix`\n    #                                       is not size 24 or 96\n    def self.from_matrix(matrix)\n      WellMatrix.new(matrix.to_a)\n    end\n\n    # Returns a new WellMatrix as a copy of the given 2D Array.\n    #\n    # @param array_2D [Array\u003cArray\u003cObject\u003e\u003e]  the 2D array which will be used\n    #              to construct a new WellMatrix\n    # @returns [WellMatrix]  new WellMatrix with identical elements\n    #          to the passed in 2D Array\n    # @raises [WellMatrixInvalidDimensionsError]\n    #                        if `array_2D` is not size 24 or 96\n    #                        or if `array_2D` does not have consistent column size\n    def self.from_array(array_2D)\n      # copy input array (1 level deep)\n      rows = Array.new(array_2D.size) do |i|\n        Array.new(array_2D[i].size) { |j| array_2D[i][j] }\n      end\n      # return new WellMatrix created from copy of given array\n      WellMatrix.new(rows)\n    end\n\n    # Returns a new 'empty' WellMatrix of the given plate size.\n    #\n    # @param size [Integer]  the size of the plate for which the\n    #             matrix is built. 24 or 96 only\n    # @param initial [Object] the initial value of all elements in\n    #                the 2D array, default is nil\n    # @returns [WellMatrix]  a new WellMatrix of the correct dimensions\n    #          for the given plate size,\n    #          initially populated with default elements\n    # @raises [WellMatrixInvalidDimensionsError]  if `size` is not 24 or 96\n    def self.create_empty(size, initial = nil)\n      if size == 24\n        rows = Array.new(4) { Array.new(6, initial) }\n      elsif size == 96\n        rows = Array.new(8) { Array.new(12, initial) }\n      else\n        raise WellMatrixInvalidDimensionsError.new,\n              'Size of matrix is not 24 or 96'\n      end\n      WellMatrix.new(rows)\n    end\n\n    # Returns the number of rows of the matrix.\n    #\n    # @return [Integer]  the number of rows in this WellMatrix\n    def row_count\n      @rows.size\n    end\n\n    # Returns the number of columns of the matrix.\n    #\n    # @return [Integer]  the number of columns in this  WellMatrix\n    def column_count\n      @rows[0].size\n    end\n\n    # Gets an element from the matrix using numeric coordinates.\n    #\n    # @param i [Integer]  the 0-based row of the desired element\n    # @param j [Integer]  the 0-based column of the desired element\n    # @return [Object]  the element of the matrix at index `i`, `j`\n    # @raises  [WellMatrixIndexOutOfBoundsError]  if the given index is out of bounds\n    def [](i, j)\n      if in_bounds?(i, j)\n        @rows[i][j]\n      else\n        raise WellMatrixIndexOutOfBoundsError.new,\n              \"index #{i},#{j} is out of bounds \"\\\n              \"0,0...#{row_count},#{column_count}\"\n      end\n    end\n\n    # Gets an element from the matrix using alphanumeric coordinates.\n    #\n    # @param alpha_coord [String]  the row column pair of the desired element,\n    #                     encoded as an alphanumeric coordinate\n    # @return [Object]  the element of the matrix at the\n    #                   index specified by `alpha_coord`\n    def get(alpha_coord)\n      coord = WellMatrix.numeric_coordinate(alpha_coord)\n      self[coord[0], coord[1]]\n    end\n\n    # Sets an element of the matrix using numeric coordinates.\n    #\n    # @param i [Integer]  the 0-based row of the element to set\n    # @param j [Integer]  the 0-based column of the element to set\n    # @param value [Object]  the element to put in the specified index\n    # @effect  sets element of the matrix at index `i`, `j` to `value`\n    # @raises  [WellMatrixIndexOutOfBoundsError]  if the given index is out of bounds\n    def []=(i, j, value)\n      if in_bounds?(i, j)\n        @rows[i][j] = value\n      else\n        raise WellMatrixIndexOutOfBoundsError.new,\n              \"index #{i},#{j} is out of bounds \"\\\n              \"0,0...#{row_count},#{column_count}\"\n      end\n    end\n\n    # Sets element of the matrix using alphanumeric coordinates.\n    #\n    # @param alpha_coord [String]  the row column pair of the element to set,\n    #                    encoded as an alpha numeric coordinate\n    # @param value [Object]  what to put in the specified index\n    # @effect  sets element of the matrix at the index specified\n    #          by `alpha_coord` to `value`\n    def set(alpha_coord, value)\n      coord = WellMatrix.numeric_coordinate(alpha_coord)\n      self[coord[0], coord[1]] = value\n    end\n\n    # Return a copy of the matrix formatted as a 2D Array.\n    #\n    # @return [Array\u003cArray\u003cObject\u003e\u003e]  copy of this WellMatrix as basic 2D Array\n    def to_array\n      # defensive copying required\n      # walk through, copy columns, retain element references\n      Array.new(row_count) do |i|\n        Array.new(column_count) { |j| @rows[i][j] }\n      end\n    end\n\n    alias to_a to_array\n\n    # Return a copy of the matrix formatted as a ruby Matrix.\n    #\n    # @return [Matrix]  copy of this WellMatrix as Matrix\n    def to_matrix\n      Matrix.rows(@rows)\n    end\n\n    alias to_m to_matrix\n\n    # Return a copy of the matrix.\n    #\n    # @return [WellMatrix]  copy of this WellMatrix\n    def clone\n      arr = to_array\n      from_array(arr)\n    end\n\n    # Creates a 2d array copy of the given WellMatrix for display with the `table` command.\n    # This display table highlights cells in purple based on a custom condition.\n    # The resulting table only displays the positions of the WellMatrix, not the elements themselves.\n    #\n    # @param [\u0026block]  the condition evaluated on each element in the matrix which decides\n    #           whether a particular cell is highlighted\n    # @return [Array]  an array copy of the WellMatrix, augmented with colors, and without original data\n    def display_position_table\n      new_table = to_array\n      row_count.times do |rr|\n        column_count.times do |cc|\n          rr_well = 'A'.ord.to_i + rr # ascii value for A-H, use .chr to convert to ascii character\n          cc_well = cc + 1 # number\n          if yield(self[rr, cc])\n            new_table[rr][cc] = { content: \"#{rr_well.chr}#{cc_well}\", style: { background: '#e6e6ff' } } # purple\n          else\n            new_table[rr][cc] = { content: \"#{rr_well.chr}#{cc_well}\", style: { background: '#000000' } } # black\n          end\n        end\n      end\n      new_table\n    end\n\n    # Creates a 2d array copy of the given WellMatrix for display with the `table` command.\n    # This display table highlights cells in purple based on a custom condition.\n    # Allows the tech to view the contents of each element in the WellMatrix.\n    #\n    # @param [\u0026block]  the condition evaluated on each element in the matrix which decides\n    #           whether a particular cell is highlighted\n    # @return [Array]  an array copy of the WellMatrix augmented with colors\n    def display_table\n      new_table = to_array\n      row_count.times do |rr|\n        column_count.times do |cc|\n          if yield(self[rr, cc])\n            new_table[rr][cc] = { content: self[rr, cc].to_s, style: { background: '#e6e6ff' } } # purple\n          else\n            new_table[rr][cc] = { content: self[rr, cc].to_s, style: { background: '#000000' } } # black\n          end\n        end\n      end\n      new_table\n    end\n\n    # Convert alphanumeric well coordinate to 0-based integer coordinate pair\n    # Alphanumeric coordinate has a single uppercase letter representing the\n    # row, and a 1-based number representing a column\n    # So, \"A01\" is the well in the upper left\n    #\n    # @param alpha_num_coordinate [String]  the input alphanumeric coordinate\n    # @return [Array\u003cInteger\u003e]  the coordinate converted to a size 2\n    #          for the numeric 0-based row and column pair\n    def self.numeric_coordinate(alpha_num_coordinate)\n      mymatch = /(?\u003cmyrow\u003e[A-Z]{1,1})(?\u003cmycol\u003e[0-9]{1,2})/\n                .match(alpha_num_coordinate)\n      # subtract ascii value of \"A\" from A-H to get row integer 0-6\n      rr = mymatch[:myrow].ord.to_i - 'A'.ord\n      cc = mymatch[:mycol].to_i - 1\n      [rr, cc]\n    end\n\n    # Returns true if the given coordinate is in the bounds of this matrix,\n    # false otherwise.\n    #\n    # @param i [Integer]  the 0-based row of the target element\n    # @param j [Integer]  the 0-based column of the target element\n    # @return [Boolean]  truth value of whether the `i`, `j` corresponds\n    #         to a coherent location in this WellMatrix\n    private def in_bounds?(i, j)\n      if i \u003e= row_count || j \u003e= column_count || i \u003c 0 || j \u003c 0\n        false\n      else\n        true\n      end\n    end\n\n    # Throws errors if this WellMatrix is not of the correct internal structure.\n    #\n    # @raises [WellMatrixInvalidDimensionsError]  when the dimensions of this\n    #         WellMatrix are incorrect\n    private def check_rep\n      num_rows = row_count\n      num_cols = column_count\n      if @rows.map(\u0026:size).uniq.size \u003e 1\n        raise WellMatrixInvalidDimensionsError.new,\n              'Row sizes are not consistent'\n      end\n      unless (num_rows == 4 \u0026\u0026 num_cols == 6) ||\n             (num_rows == 8 \u0026\u0026 num_cols == 12)\n        raise WellMatrixInvalidDimensionsError.new,\n              'Size of matrix is not 24 or 96'\n      end\n    end\n  end\n\n  # Error indicating that the dimensions of a WellMatrix do not correspond\n  # to the expected dimensions of a 24 or 96 well plate.\n  #\n  class WellMatrixInvalidDimensionsError \u003c StandardError; end\n\n  # Error indicating that there was an attempted access at an impossible index\n  # in a WellMatrix\n  #\n  class WellMatrixIndexOutOfBoundsError \u003c IndexError; end\nend\n"}},{"library":{"name":"OperationErrors","category":"Standard Libs","code_source":"# OperationErrors provides methods for dealing with operations that\n#   are errored out during a Job\n#\nmodule OperationErrors\n\n    # Creates and displays a table of all Operations that are errored\n    # @todo Make it so that associations that are not errors are not listed\\\n    #\n    def report_errors\n        return unless operations.errored.present?\n        \n        error_table = [[\"Operation ID\", \"Error\", \"Message\"]]\n        \n        operations.errored.each do |op|\n            op.associations.each do |k, v|\n                row = []\n                row \u003c\u003c op.id\n                row \u003c\u003c k\n                row \u003c\u003c v\n                error_table \u003c\u003c row\n            end\n        end\n        \n        show do\n            title \"Some Operations Have Errors\"\n            note \"Some rows may not represent error conditions, but each Operation listed has at least one fatal error.\"\n            table error_table\n            warning \"Consult with the lab manager about whether to abort this Job.\"\n        end\n    end\n    \nend"}},{"library":{"name":"Pipettors","category":"Standard Libs","code_source":"needs \"Standard Libs/Units\"\n\nmodule Pipettors\n\n  include Units\n\n  # Creates string with directions on which pipet to use and what\n  # to pipet to/from\n  #\n  # @param volume [{qty: int, unit: string}] the volume per Standard Libs Units\n  # @param source: [String] the source to pipet from\n  # @param destination: [String]the destination to pipet\n  # @param type [String] the type of pipettor if a specific one is desired\n  # @return [String] directions\n  def pipet(volume:, source:, destination:, type: nil)\n    pipettor = get_single_channel_pipettor(volume: volume,\n                                           type: type)\n    pipettor.pipet(\n      volume: volume,\n      source: source,\n      destination: destination\n    )\n  end\n\n  # Creates string with directions on which multi channel pipet to use and what\n  # to pipet to/from\n  #\n  # @param volume [{qty: int, unit: string}] the volume per Standard Libs Units\n  # @param source: [String] the source to pipet from\n  # @param destination: [String]the destination to pipet\n  # @param type [String] the type of pipettor if a specific one is desired\n  # @return [String] directions\n  def multichannel_pipet(volume:, source:, destination:, type: nil)\n    pipettor = get_multi_channel_pipettor(volume: volume, type: type)\n    pipettor.pipet(\n      volume: volume,\n      source: source,\n      destination: destination,\n    )\n  end\n\n  # Returns a single channel pipet depending on the volume\n  # \n  # @param volume [{qty: int, unit: string}] the volume per Standard Libs Units\n  # @param type [String] the type of pipettor if a specific one is desired\n  # @return [Pipet] A class of pipettor\n  def get_single_channel_pipettor(volume:, type: nil)\n    qty = type.present? ? Float::INFINITY : volume[:qty]\n    if type == P2::NAME || qty \u003c= 2\n      P2.instance\n    elsif type == P20::NAME || qty \u003c= 20\n      P20.instance\n    elsif type == P200::NAME || qty \u003c= 200\n      P200.instance\n    elsif type == P1000::NAME || qty \u003c= 1000\n      P1000.instance\n    elsif qty \u003c= 2000\n      P1000.instance\n    elsif type == PipetController::NAME || qty \u003e 2000\n      PipetController.instance\n    end\n  end\n\n  # Returns a multi channel pipet depending on the volume\n  # \n  # @param volume [{qty: int, unit: string}] the volume per Standard Libs Units\n  # @param type [String] the type of pipettor if a specific one is desired\n  # @return [Pipet] A class of pipettor\n  def get_multi_channel_pipettor(volume:, type: nil)\n    qty = type.present? ? Float::INFINITY : volume[:qty]\n    if type == P8X200::NAME || qty \u003c= 200\n      P8X200.instance\n    elsif type == PA6X1200::NAME || qty \u003c= 1000\n      PA6X1200.instance\n    end\n  end\n\n  # TODO add comment\n  class Pipettor\n    include Singleton\n    include Units\n\n    # Gives directions to use pipet\n    #\n    # @param volume [{qty: int, unit: string}] the volume per Standard Libs Units\n    # @param source: [String] the source to pipet from\n    # @param destination: [String]the destination to pipet\n    # @return [String] directions\n    def pipet(volume:, source:, destination:)\n      max_volume = self.class::MAX_VOLUME\n      if volume[:qty] \u003c= max_volume\n        volume[:qty] = volume[:qty].round(self.class::ROUND_TO) \n        a = \"Set a \u003cb\u003e#{self.class::NAME}\u003c/b\u003e pipet to \"\\\n          \"\u003cb\u003e#{qty_display(volume)}\u003c/b\u003e.\"\n        b = \"  Pipet #{qty_display(volume)} from \u003cb\u003e#{source}\u003c/b\u003e\"\\\n          \" into \u003cb\u003e#{destination}\u003c/b\u003e\"\n      else\n        times = (volume[:qty].to_f/max_volume).ceil.to_f\n        sub_volume[:qty] = (volume[:qty] / times).round(self.class::ROUND_TO)\n        a = \"Set a \u003cb\u003e#{self.class::NAME}\u003c/b\u003e pipet to \"\\\n          \"\u003cb\u003e#{qty_display(sub_volume)}\u003c/b\u003e.\"\n        b = \"  Pipet #{times} times for #{qty_display(volume)} from \u003cb\u003e#{source}\u003c/b\u003e\"\\\n          \" into \u003cb\u003e#{destination}\u003c/b\u003e\"\n      end\n      a + b\n    end\n\n    # Returns the number of channels a pipettor has\n    #\n    # @return Int\n    def channels\n      self.class::CHANNELS\n    end\n  end\n\n  class PA6X1200 \u003c Pipettor\n    NAME = '6 Channel Adjustable Space P1200'.freeze\n    MIN_VOLUME = 200.0\n    MAX_VOLUME = 1000.0\n    ROUND_TO = 0\n    CHANNELS = 6\n  end\n\n  class P8X200 \u003c Pipettor\n    NAME = '8 Channel P200'.freeze\n    MIN_VOLUME = 20.0\n    MAX_VOLUME = 200.0\n    ROUND_TO = 0\n    CHANNELS = 8\n  end\n\n  class P2 \u003c Pipettor\n    NAME = 'P2'.freeze\n    MIN_VOLUME = 0.0\n    MAX_VOLUME = 2.0\n    ROUND_TO = 1\n    CHANNELS = 1\n  end\n\n  class P20 \u003c Pipettor\n    NAME = 'P20'.freeze\n    MIN_VOLUME = 2.0\n    MAX_VOLUME = 20.0\n    ROUND_TO = 1\n    CHANNELS = 1\n  end\n\n  class P200 \u003c Pipettor\n    NAME = 'P200'.freeze\n    MIN_VOLUME = 20.0\n    MAX_VOLUME = 200.0\n    ROUND_TO = 0\n    CHANNELS = 1\n  end\n\n  class P1000 \u003c Pipettor\n    NAME = 'P1000'.freeze\n    MIN_VOLUME = 200.0\n    MAX_VOLUME = 1000.0\n    ROUND_TO = 0\n    CHANNELS = 1\n  end\n\n  class PipetController \u003c Pipettor\n    NAME = 'Pipet controller'.freeze\n    MIN_VOLUME = 2000.0\n    MAX_VOLUME = 50000.0\n    ROUND_TO = 0\n    CHANNELS = 1\n  end\n\nend\n"}},{"library":{"name":"PlanParams","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Module for handling options passed to a `Plan` or to `Operations`\n# @author Devin Strickland \u003cstrcklnd@uw.edu\u003e\nmodule PlanParams\n  # Gets `:options` from the `Plan` associations and the `Operations` and uses\n  #   them to override `default_job_params`\n  #\n  # @note\n  # @param operations [OperationList] the operations\n  # @param default_job_params [Hash] the default parameters to be applied\n  #   equally to all `Operations` in the `Job`\n  # @return [Hash] the updated parameters to be applied equally to all\n  #   `Operations` in the `Job`\n  def update_job_params(operations:, default_job_params:)\n    opts = strict_plan_options(operations)\n    job_params = update_plan_params(plan_params: default_job_params, opts: opts)\n    return job_params unless options_for?(operations)\n\n    update_from_operations(\n      operations: operations,\n      job_params: job_params\n    )\n  rescue IncompatibleParametersError =\u003e e\n    error_operations(operations: operations, err: e)\n  end\n\n  # Get Plan options from a list of Operations; raised an exception unless all\n  #   Operations come from the same Plan\n  #\n  # @param operations [Array\u003cOperation\u003e] the Operations\n  # @return [String] the options\n  def strict_plan_options(operations)\n    plans = operations.map(\u0026:plan).uniq\n\n    if plans.length \u003e 1\n      plan_ids = plans.map(\u0026:id)\n      msg = 'Operations must all be from a single Plan.' \\\n      \" #{plan_ids.length} Plans found: #{plan_ids.to_sentence}\"\n      raise IncompatibleParametersError, msg\n    end\n\n    operations.first.plan.associations[:options]\n  end\n\n  # Check to see if any of the `Operations` have `Options` set\n  #\n  def options_for?(operations)\n    operations.any? { |op| op.input('Options').try(:val).present? }\n  end\n\n  # Updates a hash from options\n  #\n  # @param plan_params [Hash] the receiver hash\n  # @param opts [Hash] the donatng hash\n  # @return [Hash]\n  # @deprecate Use {#update_params} instead\n  def update_plan_params(plan_params:, opts:)\n    update_params(default_params: plan_params, opts: opts)\n  end\n\n  # Updates a hash from options\n  #\n  # @param default_params [Hash] the receiver hash\n  # @param opts [Hash] the donatng hash\n  # @return [Hash]\n  def update_params(default_params:, opts:)\n    default_params.update(parse_options(opts)) if opts.present?\n    default_params\n  end\n\n  # Parses JSON formatted options\n  #\n  # @param opts [String] JSON-formatted string\n  # @return [Hash]\n  def parse_options(opts)\n    JSON.parse(opts, { symbolize_names: true })\n  end\n\n  # Gets `Options` from each `Operation` and uses them to update\n  #   `default_operation_params`, then applies the result to each\n  #   `Operation` at `op.temporary[:options]`\n  #\n  # @param operations [OperationList] the operations\n  # @param default_operation_params [Hash] the default parameters to be applied\n  #   to all `Operations` in the `Job` UNLESS overriden by input 'Options'\n  # @return [void]\n  def update_operation_params(operations:, default_operation_params:)\n    operations.each do |op|\n      opts = default_operation_params.dup.update(op.input('Options').val)\n      op.temporary[:options] = opts\n    end\n  end\n\n  # Convenience method for calling both {#update_job_params} and\n  #   {#update_operation_params}\n  #\n  # @param operations [OperationList] the operations\n  # @param default_job_params [Hash] the default parameters to be applied\n  #   equally to all `Operations` in the `Job`\n  # @param default_operation_params [Hash] the default parameters to be applied\n  #   to all `Operations` in the `Job` UNLESS overriden by input 'Options'\n  # @return [Hash] the updated parameters to be applied to all\n  #   `Operations` in the `Job`\n  def update_all_params(operations:, default_job_params:,\n                        default_operation_params:)\n    job_params = update_job_params(\n      operations: operations,\n      default_job_params: default_job_params\n    )\n    update_operation_params(\n      operations: operations,\n      default_operation_params: default_operation_params\n    )\n    job_params\n  end\n\n  ########## TESTING METHODS ##########\n\n  TEST_PARAMS = {\n    who_is_on_first: false\n  }.freeze\n\n  # Set everything up for testing using options\n  #\n  # @param operations [OperationList] the operations\n  # @param options [Hash] the options\n  # @return [void]\n  def setup_test_options(operations:, opts: TEST_PARAMS)\n    associate_plan_options(operations: operations, opts: opts)\n    unify_plans(operations: operations)\n  end\n\n  # Add options to the `Plan` for testing purposes\n  #\n  # @param operations [OperationList] the operations\n  # @param options [Hash] the options\n  # @return [void]\n  def associate_plan_options(operations:, opts:)\n    plan = operations.first.plan\n    plan.associate(:options, opts.to_json)\n  end\n\n  # Make all operations have the same plan\n  #\n  # @param operations [OperationList] the operations\n  # @return [void]\n  def unify_plans(operations:)\n    plan_associations = operations.map { |op| op.plan_associations.first }\n    plan = operations.first.plan\n    plan_associations.each do |pa|\n      pa.plan = plan\n      pa.save\n    end\n\n    # Needed to refresh plan associations for weird Rails reasons\n    Operation.find(operations.map(\u0026:id))\n  end\n\n  # Get an option value for a given key from the given operation\n  #\n  def get_options(operations:, key:)\n    operations.map { |op| get_option(operation: op, key: key) }\n  end\n\n  # Get an option value for a given key from the given operation\n  #\n  def get_option(operation:, key:)\n    operation.input('Options').val.fetch(key, :no_key)\n  end\n\n  private\n\n  # Update job_params based on options for the given operations\n  #\n  def update_from_operations(operations:, job_params:)\n    job_params.keys.each do |key|\n      val = strict_operations_option(operations: operations, key: key)\n      job_params[key] = val unless val == :no_key\n    end\n    job_params\n  end\n\n  # Get a list of option values for a given key from the given operations list,\n  #   or raise exception if there is more than one unique value\n  #\n  def strict_operations_option(operations:, key:)\n    val = get_options(operations: operations, key: key)\n    unless val.uniq.length == 1\n      msg = \"More than one value given in Operation Options for #{key}:\" \\\n            \" #{val}\"\n      raise IncompatibleParametersError, msg\n    end\n    val.first\n  end\n\n  # Say you're quitting due to an error and error all the operations\n  #\n  def error_operations(operations:, err:)\n    show do\n      title 'Incompatible Parameters Detected'\n      warning err.message\n    end\n\n    operations.each { |op| op.error(:incompatible_parameters, err.message) }\n  end\n\n  class IncompatibleParametersError \u003c ProtocolError; end\nend\n"}},{"library":{"name":"Preconditions","category":"Standard Libs","code_source":"module Preconditions\n  \n  # Returns true if the specified operation input was created more than delta_time in the past\n  #   e.g., time_elapsed op, \"Plasmid\", hours: 1, minutes: 30\n  def time_elapsed op, input_name, delta_time = {days: 1}\n    op.input_array(input_name).each do |input|\n      t1 = get_t1 input\n      t2 = Time.zone.now\n  \n      num_seconds = (delta_time[:minutes] || 0) * 60 +\n                    (delta_time[:hours] || 0) * 60 * 60 +\n                    (delta_time[:days] || 0) * 60 * 60 * 24\n                    \n      return false if t2 - t1 \u003c= num_seconds\n    end\n    \n    return true\n  end\n  \n  def get_t1 input_fv\n    if input_fv.item\n      return input_fv.item.created_at\n    elsif input_fv.predecessors.any?\n      return input_fv.predecessors.first.updated_at\n    else\n      return Time.zone.now\n    end\n  end\n\nend"}},{"library":{"name":"PrinterHelper","category":"Standard Libs","code_source":"# SG\n# module for label printer\nmodule PrinterHelper\n    \n    #------------------------------------------\n    # print labels for samples\n    # inputs:\n    # ioStrs - array of strings, output items\n    #------------------------------------------\n    def printLabels(ioStrs)\n\n        min_id=Float::INFINITY\n        max_id=0 \n        \n        if(!ioStrs.kind_of?(Array)) # make sure input is an array\n            ioStrs=[ioStrs]\n        end\n        \n        show do\n            title \"Use label printer to label new 1.5 mL tubes with the following numbers:\"\n            operations.each { |op|\n                ioStrs.each { |ioStr|\n                    note \"#{op.output(ioStr).item}\"\n                    min_id=[op.output(ioStr).item.id, min_id].min\n                    max_id=[op.output(ioStr).item.id, max_id].max\n                }\n            }\n            check \"Ensure that the B33-143-492 labels are loaded in the printer. This number should be displayed on the printer. If not, check with a lab manager.\"\n            check \"Open the LabelMark 6 software.\"\n            check \"Select \u003cb\u003eOpen \u003c/b\u003e --\u003e \u003cb\u003eFile\u003c/b\u003e --\u003e \u003cb\u003eSerialized data top labels\u003c/b\u003e\"\n            note \"If an error about the printer appears, press \u003cb\u003eOkay\u003c/b\u003e\"\n            check \"Select the first label graphic, and click on the number in the middle of the label graphic.\"\n            check \"On the toolbar on the left, select \u003cb\u003eEdit serialized data\u003c/b\u003e\"\n            if(max_id-min_id+1 == operations.length*ioStrs.length) # consecutive numbers\n                check \"Enter \u003cb\u003e#{min_id}\u003c/b\u003e for the Start number and \u003cb\u003e#{operations.length*ioStrs.length}\u003c/b\u003e for the Total number, and select \u003cb\u003eFinish\u003c/b\u003e\"\n            else\n                check \"Enter the listed numbers manually and select \u003cb\u003eFinish\u003c/b\u003e\"\n            end\n            check \"Select \u003cb\u003eFile\u003c/b\u003e --\u003e \u003cb\u003ePrint\u003c/b\u003e and select \u003cb\u003eBBP33\u003c/b\u003e as the printer option.\"\n            check \"Press \u003cb\u003ePrint\u003c/b\u003e and collect the labels.\"\n            image \"purify_gel_edit_serialized_data\"\n            image \"Actions/purify_gel/purify_gel_sequential\"\n        end\n    end # def\n    \nend # module"}},{"library":{"name":"Priority Queue","category":"Standard Libs","code_source":"class PriorityQueue \n  def initialize\n    @heap = Heap.new()\n    @priority_map = Hash.new()\n  end\n\n  def empty?\n    @heap.empty?\n  end\n\n  def has_key?(key)\n    @priority_map.has_key?(key)\n  end\n\n  def push(key, priority)\n    node = PriorityNode.new(value: key, priority: priority)\n    @priority_map[key] = priority\n    @heap.add!(node)\n  end\n\n  def each(\u0026blk)\n    @priority_map.each(\u0026blk)\n  end\n\n  def min\n    @heap.peek.to_pair\n  end\n\n  def min_key\n    return nil if empty?\n\n    @heap.peek.value\n  end\n\n  def min_priority\n    return nil if empty?\n\n    @heap.peek.priority\n  end\n\n  # remove min and return pair\n  def delete_min\n    return nil if empty?\n\n    min_node = @heap.remove!\n    @priority_map.delete(min_node.value)\n    min_node.to_pair\n  end\n\n  # remove min and return key\n  def delete_min_return_key\n    return nil if empty?\n\n    min_value = @heap.remove!.value\n    @priority_map.delete(min_value)\n    min_value\n  end\n\n  private\n\n  class PriorityNode\n    include Comparable\n    attr_reader :value, :priority\n\n    def initialize(value:, priority:)\n      @value = value\n      @priority = priority\n    end\n\n    def \u003c=\u003e(node)\n      @priority \u003c=\u003e node.priority\n    end\n\n    def to_pair\n      [@value, @priority]\n    end\n  end\n\nend\n\n# Based on https://cs.lmu.edu/~ray/notes/pqueues/\nclass Heap\n  def initialize\n    @heap = []\n  end\n\n  def add!(x)\n    @heap.append(x)\n    sift_up(@heap.length - 1)\n    self\n  end\n\n  def empty?\n    @heap.length == 0\n  end\n\n  def peek\n    @heap[0]\n  end\n\n  def remove!\n    return nil if empty?\n\n    value = @heap[0]\n    if @heap.length == 1\n      @heap = []\n    else\n      @heap[0] = @heap.pop\n      sift_down(0)\n    end\n    value\n  end\n\n  def to_s\n    @heap.to_s\n  end\n\n  private\n\n  # Sift up the element at index i\n  def sift_up(i)\n    parent = (i - 1) / 2\n    if parent \u003e= 0 and @heap[parent] \u003e @heap[i]\n      @heap[parent], @heap[i] = @heap[i], @heap[parent]\n      sift_up(parent)\n    end\n  end\n\n  # Sift down the element at index i\n  def sift_down(i)\n    child = (i * 2) + 1\n    return if child \u003e= @heap.length\n    child += 1 if child + 1 \u003c @heap.length and @heap[child] \u003e @heap[child+1]\n    if @heap[i] \u003e @heap[child]\n      @heap[child], @heap[i] = @heap[i], @heap[child]\n      sift_down(child)\n    end\n  end\nend"}},{"library":{"name":"ProvenanceFinder","category":"Standard Libs","code_source":"module ProvenanceFinder\n    # Finds output FieldValues for a given Item id.\n    #\n    # @param item_id [int] id of an Item\n    # @return [ActiveRecord::Relation] FieldValues\n    def output_fvs(item_id)\n        FieldValue.where(role: 'output', child_item_id: item_id) || []\n    end\n\n    # Finds input FieldValues for a given Item id.\n    #\n    # @param item_id [int] id of an Item\n    # @return [ActiveRecord::Relation] FieldValues\n    def input_fvs(item_id)\n        FieldValue.where(role: 'input', child_item_id: item_id) || []\n    end\n\n    # Finds Operations for which a given Item is an output.\n    #\n    # @param item_id [int] id of an Item\n    # @return [Array] Operations that produced this item\n    def predecessor_ops(item_id)\n        output_fvs(item_id).map { |fv| fv.operation }\n    end\n\n    # Finds Operations for which a given Item is an input.\n    #\n    # @param item_id [int] id of an Item\n    # @return [Array] Operations that used this item as input\n    def successor_ops(item_id)\n        input_fvs(item_id).map { |fv| fv.operation }\n    end\n\n    # Recursively finds the Operation backchain for a given item.\n    # Goes back to a specified OperationType, then stops.\n    #\n    # @param stop_at [string] name of the OperationType of the Operation to stop at\n    # @param item_id [int] id of an Item\n    # @param row [string] the row location if the Item is a collection\n    # @param column [string] the column location if the Item is a collection\n    # @param ops [Array] the list of operations to be returned\n    # @return [Array] the Operation backchain\n    def walk_back(stop_at, item_id, row=nil, col=nil, ops=nil)\n        ops ||= []\n\n        pred_fvs = output_fvs(item_id)\n        pred_fvs = pred_fvs.select { |fv| fv.row == row and fv.column == col }\n\n        return ops unless pred_fvs.present?\n\n        op_ids = ops.flatten.map { |op| op.id }\n        pred_op_fvs = pred_fvs.select { |fv| fv.parent_class == \"Operation\" \u0026\u0026 ! op_ids.include?(fv.parent_id) }\n        pred_op_ids = pred_op_fvs.map { |fv| fv.parent_id }\n        pred_ops = Operation.where(id: pred_op_ids)\n        # It's not clear to me why this should happen\n        return ops unless pred_ops.present?\n\n        pred_op = pred_ops.sort_by { |op| job_completed(op) }.first\n        ops.append(pred_op)\n\n        return ops if pred_op.operation_type.name == stop_at\n\n        begin\n            input_fv = get_input_fv(pred_op, item_id)\n\n        rescue InputNotFoundError =\u003e e\n            puts e.message\n            return ops\n        end\n\n        if input_fv.field_type.array == true\n            branches = []\n            pred_op.input_array(input_fv.name).each do |fv|\n                branches.append(walk_back(stop_at, fv.child_item_id, fv.row, fv.column))\n            end\n            ops.append(branches)\n        end\n\n        return walk_back(stop_at, input_fv.child_item_id, input_fv.row, input_fv.column, ops)\n    end\n\n    # Gets the completion date for the most recent Job for a given Operation.\n    #\n    # @param op [Operation]\n    # @return [DateTime]\n    def job_completed(op)\n        jobs = op.jobs.sort_by { |job| job.updated_at }\n        jobs.last.updated_at\n    end\n\n    # Determines the most likely input FieldValue for a given Operation and output Item.\n    #\n    # @param op [Operation] the Operation to search within\n    # @param output_item_id [int] the id of the output Item\n    # @return [FieldValue] the most likely input\n    def get_input_fv(op, output_item_id)\n        # If only one input, then the answer is obvious\n        inputs = op.inputs\n        return inputs[0] if inputs.length == 1\n\n        # If more than one input, then it attempts to use routing\n        routing_matches = get_routing_matches(op, output_item_id)\n        return routing_matches[0] if routing_matches.present?\n\n        # If no routing (bad developer!) then it attempts to match Sample name\n        sample_name_matches = get_sample_name_matches(op, output_item_id)\n        return sample_name_matches[0] if sample_name_matches.present?\n\n        # Gives up\n        raise InputNotFoundError.new(\n            \"No input for output item #{output_item_id} in operation #{op.id}.\"\n        )\n    end\n\n    # Returns input FieldValues for the given Operation with the same routing as the given output Item\n    #\n    # @param op [Operation]\n    # @param output_item_id [int]\n    # @return [Array] input FieldValues that have the same routing as the output\n    def get_routing_matches(op, output_item_id)\n        fvs = FieldValue.where(\n            role: 'output',\n            parent_id: op.id,\n            parent_class: 'Operation',\n            child_item_id: output_item_id\n        )\n\n        fv = fvs.last\n        op.inputs.select { |i| i.field_type \u0026\u0026 i.field_type.routing == fv.field_type.routing }\n    end\n\n    # Returns input FieldValues for the given Operation with the same Sample name as the given output Item\n    #\n    # @param op [Operation]\n    # @param output_item_id [int]\n    # @return [Array] input FieldValues that have the same sample name as the output\n    def get_sample_name_matches(op, output_item_id)\n        sn = Item.find(output_item_id).sample.name\n        return op.inputs.select { |i| i.sample \u0026\u0026 i.sample.name == sn }\n    end\nend\n\nclass InputNotFoundError \u003c StandardError\n    def message\n        \"Could not find an input for this operation\"\n    end\nend\n\nclass NoPredecessorsError \u003c StandardError\n    def message\n        \"No predecessor was found where one was expected\"\n    end\nend"}},{"library":{"name":"SortHelper","category":"Standard Libs","code_source":"# SG\n# functions for sorting operations\n# \n# used in Library Cloning/Streak Plates on Media\nmodule SortHelper\n    \n    #-----------------------------------------------------------------------------\n    # sort ops by more than one input/output attribute, at io or item level \n    # algorithm: \n    # all possible unique values 1..n are sorted lexicographically and assigned numbers [1..n]\n    # attributes add value in powers of ops.length**(k), where k is the REVERSE position of the attribute in the matrix. \n    # (most important == first.) \n    # ops.length insures that the first level is high enough \n    #-----------------------------------------------------------------------------\n    def sortByMultipleIO(ops, ioStrs, ioNames, attributeStrs, itemLevels)\n        \n        allVals_mat=Array.new()\n        ioStrs.each_with_index { |ioStr, i|\n            allVals=[]\n            keys=[]\n            hash=Hash.new()\n            caseArray=[ioStrs[i],itemLevels[i]]\n            case caseArray\n            when [\"in\",\"io\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).send(attributeStrs[i]) } \n            when [\"in\",\"item\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).item.send(attributeStrs[i]) } \n            when [\"in\",\"val\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).val } \n            when [\"in\",\"collection\"]\n                allVals = ops.map { |op| op.input(ioNames[i]).collection.send(attributeStrs[i]) } \n            when [\"out\",\"io\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).send(attributeStrs[i]) } \n            when [\"out\",\"item\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).item.send(attributeStrs[i]) } \n            when [\"out\",\"val\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).val } \n            when [\"out\",\"collection\"]\n                allVals = ops.map { |op| op.output(ioNames[i]).collection.send(attributeStrs[i]) } \n            else\n                raise \"Bad ioStr #{ioStr} in #{__method__.to_s}, please check!\"\n            end\n            \n            begin\n                keys=allVals.uniq.sort \n            rescue\n                raise \"Can't sort [#{ioStrs[i]},#{itemLevels[i]}] in \u003cb\u003e#{__method__.to_s}\u003c/b\u003e, please check!\"\n            end\n            \n            values=Array (0..keys.length-1)\n            values.map! {|v| v=v*( (ops.length+1)**(ioStrs.length - i) ) }\n            hash=Hash[keys.zip(values)]\n            allVals_mat[i]=hash\n        }\n        \n        ops.sort! { |a, b| sortVal(a, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat)  \u003c=\u003e sortVal(b, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat) }\n        return ops\n    end # def\n  \n    #-----------------------------------------------------------------------------\n    # get op value for sort  \n    #-----------------------------------------------------------------------------\n    def sortVal(op, ioStrs, ioNames, attributeStrs, itemLevels, allVals_mat)\n        val = 0\n        allVals_mat.each_with_index { |hash, i|\n            case [ioStrs[i],itemLevels[i]]\n            when [\"in\",\"io\"]\n                val += hash[op.input(ioNames[i]).send(attributeStrs[i])]\n            when [\"in\",\"item\"]\n                val += hash[op.input(ioNames[i]).item.send(attributeStrs[i])] \n            when [\"in\",\"val\"]\n                val += hash[op.input(ioNames[i]).val] \n            when [\"in\",\"collection\"]\n                val += hash[op.input(ioNames[i]).collection.send(attributeStrs[i])] \n            when [\"out\",\"io\"]\n                val += hash[op.output(ioNames[i]).send(attributeStrs[i])] \n            when [\"out\",\"item\"]\n                val += hash[op.output(ioNames[i]).item.send(attributeStrs[i])] \n            when [\"out\",\"val\"]\n                val += hash[op.output(ioNames[i]).val] \n            when [\"out\",\"collection\"]\n                val += hash[op.output(ioNames[i]).collection.send(attributeStrs[i])] \n            else\n                raise \"Bad input [#{ioStrs[i]},#{itemLevels[i]}] in \u003cb\u003e#{__method__.to_s}\u003c/b\u003e, please check!\"\n            end\n        }\n        return val\n    end # def\n     \nend # module"}},{"library":{"name":"TemporaryTubeLabels","category":"Standard Libs","code_source":"# Library for handling temporary tube labels used during operations.\n#\n# Assigns simplified labes to the OUTPUT Item of each operation.\n# The basic method labels them as `[1,2,3,...]`, but this can be overridden.\nmodule TemporaryTubeLabels\n    def txfr_tube_labels(op, in_handle, out_handle)\n        op.output(out_handle).item.associate :sample_tube_label, op.input(in_handle).item.associations[:sample_tube_label]\n    end\n\n    def sample_tube_label(obj, handle=nil)\n        tube_label(obj, 'sample', handle)\n    end\n\n    def treatment_tube_label(obj, handle=nil)\n        tube_label(obj, 'treatment', handle)\n    end\n\n    def tube_label(obj, type, handle=nil)\n        item = handle ? obj.output(handle).item : obj\n        item.associations[\"#{type}_tube_label\".to_sym]\n    end\n\n    def tube_label_display(type, handle)\n      labels = operations.map { |op| tube_label(op, type, handle) }\n      case labels.length\n      when 1\n        labels[0]\n      when 2..5\n        labels.join(\", \")\n      else\n        \"#{labels.min}-#{labels.max}\"\n      end\n    end\n\n    def associate_sample_tube_labels(handle)\n        associate_tube_labels('sample', handle)\n    end\n\n    # Assigns an incremental tube number for each output\n    #\n    def associate_tube_labels(type, handle)\n        operations.each_with_index do |op, i|\n            op.output(handle).item.associate(\"#{type}_tube_label\".to_sym, \"#{i + 1}\")\n        end\n    end\nend"}},{"library":{"name":"Units","category":"Standard Libs","code_source":"module Units\n    \n    EMPTY = -1\n    \n    # Special Characters\n    MU = '\u0026mu;'\n    DEGREES = '\u0026deg;'\n    \n    # Prefixes\n    PICO = 'p'\n    NANO = 'n'\n    MICRO = MU\n    MILLI = 'm'\n    KILO = 'k'\n    MEGA = 'M'\n    GIGA = 'G'\n    \n    # Volume\n    LITERS = 'l'\n    MICROLITERS = MICRO + LITERS\n    MILLILITERS = MILLI + LITERS\n    \n    # Weight\n    GRAMS = 'g'\n    NANOGRAMS = NANO + GRAMS\n    MICROGRAMS = MICRO + GRAMS\n    \n    # Concentration\n    MOLAR = 'M'\n    PICOMOLAR = PICO + MOLAR\n    NANOMOLAR = NANO + MOLAR\n    MICROMOLAR = MICRO + MOLAR\n    MILLIMOLAR = MILLI + MOLAR\n    \n    # Temperature\n    CELSIUS = 'C'\n    DEGREES_C = DEGREES + CELSIUS\n    \n    # Time\n    MINUTES = 'min'\n    SECONDS = 'sec'\n    HOURS ='hr'\n    \n    # Force\n    TIMES_G = 'x g'\n    \n    # R/DNA Length\n    BASEPAIRS = 'bp'\n    KILOBASEPAIRS = KILO + BASEPAIRS\n    MEGABASEPAIRS = MEGA + BASEPAIRS\n    GIGABASEPAIRS = GIGA + BASEPAIRS\n    \n    # Voltage\n    VOLTS = 'V'\n    MILLIVOLTS = MILLI + VOLTS\n\n    def self.qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def add_qty_display(options)\n        new_items = {}\n        \n        options.each do |key, value|\n            key =~ /^(.+_)+([a-z]+)$/\n            \n            case $2\n            when 'microliters'\n                units = MICROLITERS\n            when 'milliliters'\n                units = MILLILITERS\n            when 'minutes'\n                units = MINUTES\n            else\n                next\n            end\n            \n            qty = value.to_f\n            \n            new_items[\"#{$1}qty\".to_sym] = { qty: qty, units: units }\n        end\n        \n        options.update(new_items)\n    end\n    \n    # Return the unit constant for the the unit name if there is one.\n    #\n    # @param unit_name [String] the name of the unit\n    # @returns the value of the constant with the given name\n    # @raises BadUnitNameError if the name is not the name of a defined unit\n    def self.get_unit(unit_name:)\n        self.const_get(unit_name.upcase)\n      rescue\n        raise BadUnitNameError.new(name: unit_name)\n    end\n    \n    # Exception class for bad unit name arguments to Units::get_unit.\n    #\n    # @attr_reader [String] name  the bad unit name\n    class BadUnitNameError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"Unknown unit name\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n    \n    # Return a key for the measure hash defined on the given object type.\n    #\n    # The measure hash must be defined in the data proerty of the object type as JSON.\n    # For instance\n    #\n    #   { \"measure\": { \"type\": \"concentration\", \"unit\": \"micromolar\" } }\n    #\n    # The key is constructed as the type name, an underscore, and the unit name.\n    #\n    # @param object_type [ObjectType] the object type\n    # @returns the key for the measure of the the object type if there is one\n    # @raises MissingObjectTypeMeasure if the object type has no measure data_object\n    def self.get_measure_key(object_type:)\n        data_object = object_type.data_object\n        raise MissingObjectTypeMeasureError.new(name: object_type.name) if !data_object.key?(:measure)\n        \n        measure = object_type.data_object[:measure]\n        type_name = measure[:type]\n        unit_name = measure[:unit]\n        \"#{type_name}_#{self.get_unit(unit_name: unit_name)}\"\n    end\n    \n    # Exception class for an object type with out a measure hash definition.\n    #\n    # @attr_reader [String] name  the name of the object type where measure has was expected\n    class MissingObjectTypeMeasureError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"ObjectType has no measure in data object\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n   \nend"}},{"library":{"name":"UploadHelper","category":"Standard Libs","code_source":"# written by SG\n# helper function for uploading files\n# note: data associations should be handled externally\nmodule UploadHelper\n    \n    require 'csv'\n    require 'open-uri'\n    \n    #------------------------------------------\n    # upload files \n    #\n    # inputs:\n    # dirname - directory where files are located, or full path including filename\n    # expUploadNum - expected number of files to upload\n    # tries - max. number of attempts to upload expectedNum files \n    #\n    # returns: array of Upload items \n    #\n    # EXAMPLES of how to associate correctly:     \n    # data associations - 1st gel image        \n    # up_bef=ups[0]\n    # op.plan.associate \"gel_image_bef\", \"combined gel fragment\", up_bef  # upload association, link \n    # op.input(INPUT).item.associate \"gel_image_bef\", up_bef              # regular association\n    # op.output(OUTPUT).item.associate \"gel_image_bef\", up_bef            # regular association \n    #------------------------------------------\n    def uploadData(dirname, expUploadNum, tries)\n\n        uploads={}      # holds result of upload block   \n        numUploads=0    # number of uploads in current attempt\n        attempt=0       # number of upload attempts\n            \n        # get uploads\n        loop do\n            #if(numUploads==expUploadNum)  \n            #    show {note \"Upload complete.\"}\n            #end\n            break if ( (attempt\u003e=tries) || (numUploads==expUploadNum) ) # stopping condition\n            attempt=attempt+1;\n            uploads = show do\n                title \"Select \u003cb\u003e#{expUploadNum}\u003c/b\u003e file(s)\"\n                note \"File(s) location is: #{dirname}\"\n                if(attempt\u003e1)\n                    warning \"Number of uploaded files (#{numUploads}) was incorrect, please try again! (Attempt #{attempt} of #{tries})\"\n                end\n                upload var: \"files\"\n            end\n            # number of uploads    \n            if(!uploads[:files].nil?)\n                numUploads=uploads[:files].length\n            end\n        end\n        \n        if(numUploads!=expUploadNum)\n            show {note \"Final number of uploads (#{numUploads}) not equal to expected number #{expUploadNum}! Please check.\"}\n            return nil\n        end\n        \n        # format uploads before returning \n        ups=Array.new # array of upload hashes\n        if (!uploads[:files].nil?)\n            uploads[:files].each_with_index do |upload_hash, ii|\n                up=Upload.find(upload_hash[:id]) \n                ups[ii]=up\n            end\n        end\n        \n        # return\n        ups\n        \n    end # def\n    \n    \n    # Opens .csv file upload item using its url and stores it line by line in a matrix\n    #\n    # @param upload [upload_obj] the file that you wish to read from\n    # @return matrix [2D-Array] is the array of arrays of the rows read from file, if csv\n    def read_url(upload)\n        url = upload.url\n        matrix = []\n        CSV.new(open(url)).each {|line| matrix.push(line)}\n        # open(url).each {|line| matrix.push(line.split(',')}\n        return matrix\n    end\n     \nend # module\n\n   "}}]}